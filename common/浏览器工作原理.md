呈现引擎

	解析HTML和CSS，创建结构树，
	使用CSS解析后结果和结构树创建render tree，
	制作矩形占位并决定显示顺序，并根据css解析结果确定确切坐标
	由呈现引擎遍历render tree，调用UI backend 逐一绘制节点
	
	PS: 这是一个渐进过程，不会等待所有HTML资源，部分加载部分解析
	

HTML解析

	1 HTML 无法用常规的自上而下或自下而上的解析器进行解析
	
	1. 语言的宽容本质。
	2. 浏览器历来对一些常见的无效 HTML 用法采取包容态度。
	3. 解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。
	
	
	2 HTML解析分为标记化和结构树2部分
	
	标记化就是词法分析
	树构建器通过标记化阶段的标记序列创建dom tree 
	html文件正常解析完成后(document ready : DOMContentLoaded, onreadytstatechange)，进入解析结束后的操作，在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发 (window onload)
	
	
	3 预解析
	
	WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。
	PS: 预解析是性能提升非常关键的组成部分，这意味着加载其他资源不会被你的解析所中断，但是这并不意味着JS文件的解析顺序会有问题，因为JS解析器是单线程的，JS文件加载完即开始解析，如果标记defer那么会在document ready时候开始解析，异步是同理的，相当于推迟到document ready时解析。
	

CSS样式

	1 样式表层叠顺序
	
	浏览器声明
	用户普通声明
	作者普通声明
	作者重要声明
	用户重要声明
	
	2 特异性
	
	如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)
	记为选择器中 ID 属性的个数 (= b)
	记为选择器中其他属性和伪类的个数 (= c)
	记为选择器中元素名称和伪元素的个数 (= d)
	
	3 reflow
	全局布局和增量布局: 只有标记dirty的才会reflow
	异步布局和同步布局: 
		增量布局是异步执行的。
		请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。
		全局布局往往是同步触发的。 
		有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。
		
		
	4 repaint
	全局绘制和增量绘制: 展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。
	
	5 WebKit 矩形存储
	在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。
	
	6 定位方案
	block 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。
	相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。
	浮动框会移动到行的左边或右边。
	绝对定位和固定定位，元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。
	请注意，即使在文档滚动时，固定框也不会移动。
		
		
		