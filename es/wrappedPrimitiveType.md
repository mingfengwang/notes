在使用原型继承来的属性时，有两种可能的行为，这取决于属性的具体性质——属性描述符的类型。  
如果是数据描述符（d），那么d.value总是指向这个数据的值本身；  
如果是存取描述符，那么d.get()和d.set()将分别指向属性的存取方法。  

我们一般称 x 这样的标识符为名字,而称 1 这样的数值为字面量,字面量是一个数据的文本表示，那么标识符往往就成为了字面量的名字标识  
字面量一般直接处理  
标识符会创建为一个引用  

js中数据描述符有时候会被隐式的转换成包装类型，因为只有对象才会有属性调用  
x.toString()就是其中之一 等价于 Object(x).toString()  
因为这里的x是值类型数据，值类型数据本身并不是对象，因此也不可能拥有自有的属性表。所以toString这个方法是属于其对应包装类的原型属性或方法  

1.toString会报错，不是因为1.toString找不到对应方法，也不是1无法转换，而是因为作为数字字面量，"1.xxxx"是有语法意义的，表示浮点数。因而1.和1.0都是当浮点数来解析的。  

1 in 1..constructor 等价于 1 in Number(1.0).constructor  
但是由于.constructor不是字面量1.的自由属性，所有他的结果是有原型决定的  
Number[1] = true 就改变了1 in 1..constructor的结果，因为Number.prototype.constructor缺省的情况下，指向函数本身也就是Number()自身  

[] 的求值过程  
[] 属于对象类型，对象类型到值类型的转换过程  
对象转值类型的规范过程称为：ToPrimitive,分为三个步骤：  
1. 判断对象是否实现 [Symbol.toPrimitive] 属性，如果实现调用它，并判断返回值是否为值类型，如果不是，执行下一步。  
2. 如果转换类型为 string，依次尝试调用 toString() 和 valueOf() 方法，如果 toString() 存在，并正确返回值类型就不会执行 valueOf()。  
3. 如果转换类型为 number/default，依次尝试调用 valueOf() 和 toString()，如果 valueOf() 存在，并正确返回值类型就不会执行 toString()。   
```[] + '' 
```  就等价于 
```
	'' + ''
```结果为```''```	  

```+ []```
就等价于 ```+ ''```
结果为 0
 